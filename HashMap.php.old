<?hh // strict
/**
 * @copyright   2010-2013, The Titon Project
 * @license     http://opensource.org/licenses/bsd-license.php
 * @link        http://titon.io
 */

namespace Titon\Type;

use Titon\Type\Contract\Arrayable;
use Titon\Type\Contract\Jsonable;
use Titon\Type\Contract\Xmlable;
use Titon\Type\Exception\InvalidFormatException;
use Titon\Utility\Converter;
use Titon\Utility\Hash;
use \Closure;
use \ArrayIterator;
use \IteratorAggregate;
use \Countable;

/**
 * The Map type allows for the modification, manipulation and traversal of an array through the use of an object like interface.
 * One can also modify the map using a series of chained method calls that sequentially alter the initial value.
 *
 * @package Titon\Type
 */
class HashMap extends Type implements Countable, IteratorAggregate, Arrayable, Jsonable, Xmlable {

    /**
     * Compares the current array against the passed array and returns a new array
     * with all the values that are found within both arrays. If strict is true,
     * the keys must match as well as the values. A callback can be passed to
     * further filter down the results.
     *
     * If options.on equals "keys":
     * Compares the current array against the passed array and returns a new array
     * with all the values where keys are matched in both arrays.
     * Only differences from the class instance is returned.
     *
     * If options.valueCallback is set:
     * Works exactly like default compare() except that it uses a callback to validate the values.
     * A second callback can be used to also compared against the array key.
     *
     * @uses Titon\Utility\Hash
     *
     * @param array $array
     * @param mixed $options {
     *      @type bool $strict              Will validate the array keys as well
     *      @type \Closure $callback        Closure to compare keys with
     *      @type \Closure $valueCallback   Closure to compare values with
     *      @type string $on                Either "keys" or "values"
     * }
     * @return array
     */
    public function compare(array $array, array $options = []) {
        $options = $options + [
            'strict' => true,
            'callback' => null,
            'valueCallback' => null,
            'on' => 'values'
        ];

        $callback = $options['callback'];
        $valueCallback = $options['valueCallback'];

        // Prepare array
        $value = Hash::filter($this->value(), false, function($val) {
            return !is_array($val);
        });

        // Values
        if ($options['on'] === 'values') {

            // Compare with callback
            if ($valueCallback instanceof Closure) {
                if ($callback instanceof Closure) {
                    $output = array_uintersect_uassoc($value, $array, $valueCallback, $callback);

                } else if ($options['strict']) {
                    $output = array_uintersect_assoc($value, $array, $valueCallback);

                } else {
                    $output = array_uintersect($value, $array, $valueCallback);
                }

            // Compare regular
            } else {
                if ($options['strict']) {
                    if ($callback instanceof Closure) {
                        $output = array_intersect_uassoc($value, $array, $callback);

                    } else {
                        $output = array_intersect_assoc($value, $array);
                    }
                } else {
                    $output = array_intersect($value, $array);
                }
            }

        // Keys
        } else {
            if ($callback instanceof Closure) {
                $output = array_intersect_ukey($value, $array, $callback);

            } else {
                $output = array_intersect_key($value, $array);
            }
        }

        return new static($output);
    }

    /**
     * Compares the current array against the passed array and returns a new array
     * with all the values that are not found within the passed array. If strict is true,
     * the keys must match as well as the values. A callback can be passed to
     * further filter down the results.
     *
     * If options.on equals "keys":
     * Compares the current array against the passed array and returns a new array
     * with all the values where keys are not matched in both arrays.
     * Only differences from the class instance is returned.
     *
     * If options.valueCallback is set:
     * Works exactly like default difference() except that it uses a callback to validate the values.
     * A second callback can be used to also compared against the array key.
     *
     * @uses Titon\Utility\Hash
     *
     * @param array $array
     * @param mixed $options {
     *      @type bool $strict              Will validate the array keys as well
     *      @type \Closure $callback        Closure to compare keys with
     *      @type \Closure $valueCallback   Closure to compare values with
     *      @type string $on                Either "keys" or "values"
     * }
     * @return array
     */
    public function difference(array $array, array $options = []) {
        $options = $options + [
            'strict' => true,
            'callback' => null,
            'valueCallback' => null,
            'on' => 'values'
        ];

        $callback = $options['callback'];
        $valueCallback = $options['valueCallback'];

        // Prepare array
        $value = Hash::filter($this->value(), false, function($val) {
            return !is_array($val);
        });

        // Values
        if ($options['on'] === 'values') {

            // Compare with callback
            if ($valueCallback instanceof Closure) {
                if ($callback instanceof Closure) {
                    $output = array_udiff_uassoc($value, $array, $valueCallback, $callback);

                } else if ($options['strict']) {
                    $output = array_udiff_assoc($value, $array, $valueCallback);

                } else {
                    $output = array_udiff($value, $array, $valueCallback);
                }

            // Compare regular
            } else {
                if ($options['strict']) {
                    if ($callback instanceof Closure) {
                        $output = array_diff_uassoc($value, $array, $callback);

                    } else {
                        $output = array_diff_assoc($value, $array);
                    }
                } else {
                    $output = array_diff($value, $array);
                }
            }

            // Keys
        } else {
            if ($callback instanceof Closure) {
                $output = array_diff_ukey($value, $array, $callback);

            } else {
                $output = array_diff_key($value, $array);
            }
        }

        return new static($output);
    }

    /**
     * Attempt to find an object whose property matches a specific value.
     * Can optionally pass a custom finder callback.
     *
     * @param mixed $search
     * @param string $key
     * @return mixed
     */
    public function find($search, $key = 'id') {
        $callback = $this->_buildFinder($key, $search);

        foreach ($this->value() as $value) {
            if ($callback($value)) {
                return $value;
            }
        }

        return null;
    }

    /**
     * Attempt to find multiple objects whose property matches a specific value.
     * Can optionally pass a custom finder callback.
     *
     * @param mixed $search
     * @param string $key
     * @return $this
     */
    public function findMany($search, $key = 'id') {
        $callback = $this->_buildFinder($key, $search);

        return new static($this->filter($callback, false)->values());
    }


    /**
     * Pluck the value of a specific field from each entity.
     *
     * @param string $key
     * @return array
     */
    public function pluck($key = 'id') {
        return array_map(function($value) use ($key) {
            return $value[$key];
        }, $this->value());
    }

    /**
     * Prepare the callback to use for finding.
     *
     * @param string $key
     * @param mixed $search
     * @return callable
     */
    protected function _buildFinder($key, $search) {
        if ($search instanceof Closure) {
            return $search;
        }

        return function($value) use ($search, $key) {
            if (is_array($search)) {
                return in_array($value[$key], $search);
            }

            return ($value[$key] == $search);
        };
    }

}
