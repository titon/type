<?hh // strict
/**
 * @copyright   2010-2013, The Titon Project
 * @license     http://opensource.org/licenses/bsd-license.php
 * @link        http://titon.io
 */

namespace Titon\Type;

use Titon\Type\Contract\Arrayable;
use Titon\Type\Contract\Jsonable;
use Titon\Type\Contract\Xmlable;
use Titon\Type\Exception\InvalidFormatException;
use Titon\Utility\Converter;
use Titon\Utility\Hash;
use \Closure;
use \ArrayIterator;
use \IteratorAggregate;
use \Countable;

/**
 * The Map type allows for the modification, manipulation and traversal of an array through the use of an object like interface.
 * One can also modify the map using a series of chained method calls that sequentially alter the initial value.
 *
 * @package Titon\Type
 */
class HashMap extends Type implements Countable, IteratorAggregate, Arrayable, Jsonable, Xmlable {

    /**
     * Compares the current array against the passed array and returns a new array
     * with all the values that are found within both arrays. If strict is true,
     * the keys must match as well as the values. A callback can be passed to
     * further filter down the results.
     *
     * If options.on equals "keys":
     * Compares the current array against the passed array and returns a new array
     * with all the values where keys are matched in both arrays.
     * Only differences from the class instance is returned.
     *
     * If options.valueCallback is set:
     * Works exactly like default compare() except that it uses a callback to validate the values.
     * A second callback can be used to also compared against the array key.
     *
     * @uses Titon\Utility\Hash
     *
     * @param array $array
     * @param mixed $options {
     *      @type bool $strict              Will validate the array keys as well
     *      @type \Closure $callback        Closure to compare keys with
     *      @type \Closure $valueCallback   Closure to compare values with
     *      @type string $on                Either "keys" or "values"
     * }
     * @return array
     */
    public function compare(array $array, array $options = []) {
        $options = $options + [
            'strict' => true,
            'callback' => null,
            'valueCallback' => null,
            'on' => 'values'
        ];

        $callback = $options['callback'];
        $valueCallback = $options['valueCallback'];

        // Prepare array
        $value = Hash::filter($this->value(), false, function($val) {
            return !is_array($val);
        });

        // Values
        if ($options['on'] === 'values') {

            // Compare with callback
            if ($valueCallback instanceof Closure) {
                if ($callback instanceof Closure) {
                    $output = array_uintersect_uassoc($value, $array, $valueCallback, $callback);

                } else if ($options['strict']) {
                    $output = array_uintersect_assoc($value, $array, $valueCallback);

                } else {
                    $output = array_uintersect($value, $array, $valueCallback);
                }

            // Compare regular
            } else {
                if ($options['strict']) {
                    if ($callback instanceof Closure) {
                        $output = array_intersect_uassoc($value, $array, $callback);

                    } else {
                        $output = array_intersect_assoc($value, $array);
                    }
                } else {
                    $output = array_intersect($value, $array);
                }
            }

        // Keys
        } else {
            if ($callback instanceof Closure) {
                $output = array_intersect_ukey($value, $array, $callback);

            } else {
                $output = array_intersect_key($value, $array);
            }
        }

        return new static($output);
    }

    /**
     * Compares the current array against the passed array and returns a new array
     * with all the values that are not found within the passed array. If strict is true,
     * the keys must match as well as the values. A callback can be passed to
     * further filter down the results.
     *
     * If options.on equals "keys":
     * Compares the current array against the passed array and returns a new array
     * with all the values where keys are not matched in both arrays.
     * Only differences from the class instance is returned.
     *
     * If options.valueCallback is set:
     * Works exactly like default difference() except that it uses a callback to validate the values.
     * A second callback can be used to also compared against the array key.
     *
     * @uses Titon\Utility\Hash
     *
     * @param array $array
     * @param mixed $options {
     *      @type bool $strict              Will validate the array keys as well
     *      @type \Closure $callback        Closure to compare keys with
     *      @type \Closure $valueCallback   Closure to compare values with
     *      @type string $on                Either "keys" or "values"
     * }
     * @return array
     */
    public function difference(array $array, array $options = []) {
        $options = $options + [
            'strict' => true,
            'callback' => null,
            'valueCallback' => null,
            'on' => 'values'
        ];

        $callback = $options['callback'];
        $valueCallback = $options['valueCallback'];

        // Prepare array
        $value = Hash::filter($this->value(), false, function($val) {
            return !is_array($val);
        });

        // Values
        if ($options['on'] === 'values') {

            // Compare with callback
            if ($valueCallback instanceof Closure) {
                if ($callback instanceof Closure) {
                    $output = array_udiff_uassoc($value, $array, $valueCallback, $callback);

                } else if ($options['strict']) {
                    $output = array_udiff_assoc($value, $array, $valueCallback);

                } else {
                    $output = array_udiff($value, $array, $valueCallback);
                }

            // Compare regular
            } else {
                if ($options['strict']) {
                    if ($callback instanceof Closure) {
                        $output = array_diff_uassoc($value, $array, $callback);

                    } else {
                        $output = array_diff_assoc($value, $array);
                    }
                } else {
                    $output = array_diff($value, $array);
                }
            }

            // Keys
        } else {
            if ($callback instanceof Closure) {
                $output = array_diff_ukey($value, $array, $callback);

            } else {
                $output = array_diff_key($value, $array);
            }
        }

        return new static($output);
    }

    /**
     * Attempt to find an object whose property matches a specific value.
     * Can optionally pass a custom finder callback.
     *
     * @param mixed $search
     * @param string $key
     * @return mixed
     */
    public function find($search, $key = 'id') {
        $callback = $this->_buildFinder($key, $search);

        foreach ($this->value() as $value) {
            if ($callback($value)) {
                return $value;
            }
        }

        return null;
    }

    /**
     * Attempt to find multiple objects whose property matches a specific value.
     * Can optionally pass a custom finder callback.
     *
     * @param mixed $search
     * @param string $key
     * @return $this
     */
    public function findMany($search, $key = 'id') {
        $callback = $this->_buildFinder($key, $search);

        return new static($this->filter($callback, false)->values());
    }

    /**
     * Group all values into sub-groups based on the value of a specific key.
     *
     * @param string $key
     * @return array
     */
    public function groupBy($key) {
        $grouped = [];
        $class = get_class($this);

        foreach ($this->value() as $value) {
            $grouped[$value[$key]][] = $value;
        }

        return array_map(function($value) use ($class) {
            return new $class($value);
        }, $grouped);
    }

    /**
     * Returns the index in which the passed key exists. Validates against literal and numeric keys.
     *
     * @param mixed $key
     * @return int
     */
    public function indexOf($key) {
        $count = 0;

        if ($this->isNotEmpty()) {
            foreach ($this->value() as $index => $value) {
                if ($index === $key) {
                    return $count;
                }

                ++$count;
            }
        }

        return -1;
    }

    /**
     * Pluck the value of a specific field from each entity.
     *
     * @param string $key
     * @return array
     */
    public function pluck($key = 'id') {
        return array_map(function($value) use ($key) {
            return $value[$key];
        }, $this->value());
    }

    /**
     * Sort the values in the array based on the supplied options.
     *
     * @param mixed $options {
     *      @type bool $reverse         Will reverse sort
     *      @type bool $preserve        Indices will be left in tact
     *      @type int $flags            Sorting flags
     *      @type \Closure $callback    Closure callback to sort with
     *      @type string $on            Either "keys" or "values"
     * }
     * @return $this
     */
    public function sort($options = []) {
        if ($options instanceof Closure) {
            $options = ['callback' => $options];

        } else if (is_bool($options)) {
            $options = ['reverse' => $options];
        }

        $options = $options + [
            'reverse' => false,
            'preserve' => true,
            'flags' => SORT_REGULAR,
            'callback' => null,
            'on' => 'values'
        ];

        $values = $this->value();
        $flags = $options['flags'];
        $preserve = $options['preserve'];

        // Sort by callback
        if ($options['callback'] instanceof Closure) {

            // Sort keys by callback
            if ($options['on'] === 'keys') {
                uksort($values, $options['callback']);

            // Sort values by callback
            } else {
                if ($preserve) {
                    uasort($values, $options['callback']);
                } else {
                    usort($values, $options['callback']);
                }
            }

        // Sort regular
        } else {

            // Sort by keys
            if ($options['on'] === 'keys') {
                ksort($values, $flags);

            // Sort by values
            } else {
                if ($preserve) {
                    asort($values, $flags);
                } else {
                    sort($values, $flags);
                }
            }
        }

        // Reverse it
        if ($options['reverse']) {
            $values = array_reverse($values, $preserve);
        }

        return new static($values);
    }

    /**
     * Sort a multi-dimensional array by a field within each value.
     *
     * @param string|\Closure $key
     * @param int $flags
     * @param bool $reverse
     * @return $this
     */
    public function sortBy($key, $flags = SORT_REGULAR, $reverse = false) {
        if ($key instanceof Closure) {
            $callback = $key;
        } else {
            $callback = function($a, $b) use ($key) {
                return strcmp($a[$key], $b[$key]);
            };
        }

        return $this->sort([
            'reverse' => $reverse,
            'preserve' => false,
            'flags' => $flags,
            'callback' => $callback
        ]);
    }

    /**
     * Sort the array using a natural algorithm. This function implements a sort algorithm that orders
     * alphanumeric strings in the way a human being would while maintaining key/value associations.
     *
     * @param bool $strict
     * @return $this
     */
    public function sortNatural($strict = false) {
        $values = $this->value();

        if ($strict) {
            natsort($values);
        } else {
            natcasesort($values);
        }

        return new static($values);
    }

    /**
     * Prepare the callback to use for finding.
     *
     * @param string $key
     * @param mixed $search
     * @return callable
     */
    protected function _buildFinder($key, $search) {
        if ($search instanceof Closure) {
            return $search;
        }

        return function($value) use ($search, $key) {
            if (is_array($search)) {
                return in_array($value[$key], $search);
            }

            return ($value[$key] == $search);
        };
    }

}
